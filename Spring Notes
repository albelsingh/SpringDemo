Rest API:-(web services) 
Application ---------Request-------------------------------->Web services(Cloud) like -servlet
                    <---------Response(HTML)-----XML/JSON---
					
Instead o sending page. we can send data into XML/JSON formate ....as a object.

JSON: (Javascript object  notation)- its format through which you can send the data client to server and server to client.

Apps (Client) ---------Request-------------------------------->Server
                    <---------Response 1(HTML)-------------------- (Hello World)
					<---------Response 2-------------XML/JSON--Emp(eid =1,
					                      var  emp = {eid:  "1",               ename=albel,
													ename: "albel",				  sal=100)
					                                	    sal: "100"}
															
NoSQL: there is no need of schema for storing the data.It don't bother about schema Simply stored the data into DB. Whatever it is it just stored in DB.
1. High speed of transaction
2. flexibility of storing data

Document type DB - Json object - like-MongoDB
Key -Value DB - like -Radis DB everything will be stored in Key-Value paire.
Wide Column DB- Everything will be stored in columns form instead of rows. like Cassandra
Graph/Node DB- Everything will be stored in form of node. like Neo4j used by FB
------------------------------------------------


-----------------SPRING---------------------
Developer- Red Johnson
Org- Spring org
First name- Interface 21
Spring came as alternative for EJB(Enterprize Java Beans)
EJB is tightly coupled and heavy weight

Heavy & Light Weight:-
AWT uses the os liabrary and swing uses the jdk liabrary.So AWT is Heavy weight and Swing is light weight.
Like this EJB having dependency of application server while Spring without having platform dependency it uses spring jar and jdk.
EJB is heavy weight and Spring is light weight

Tightly & Loosely coupled:-
EJB is tightly coupled and spring is loosely coupled
Loosely coupled possible by using java run time polymorphism.
Spring promotes association(has a relationship) instead of inheritance because it makes class light weight and loosely coupled.

Spring follow two concepts:
RTP
Has a relationship

IOC (inversion of control): container means they will read data from xml and pass it to POJO class into associate reference.
Core- BeanFactory(I)
J2EE- ApplicationContext(I)

MVC: web container(web application context)(on the top of the IOC they have built it).

Tomcat(Servlet) Container:-
1.It reads web.xml file
2.It will understand configurration and by using configurration it will create object java class
3.It will call life cycle init() and destroy() method.
4. Dynamic parameter pass to servlet class as init parameter and context parameter


IOC Container:-
1.It reads web.xml file
2.It will understand configuration and by using configurration it will create object of POJO class
3.It will manage life cycle of POJO class.
4. Dynamic parameter pass to POJO class.
-----------------------------------------------------------------------------------------------------------------------------------------
more content for video 2-3
----------------------------------------------------------------------------------------------------------------------------------------
part-4
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IOC Part -1

container
core - BeanFactory(I)-xmlBeanFactory(C)
J2EE- ApplicationContext(I)->Configurable ApplicationContext(I)->classPathxmlApplicationContext(C)
Web - WebApplicationContext(I)->WebApplicationContextUtil(C)

Do:
1).  Create instance of POJO classes.
2).  Manage life cycle of POJO classes.
3).  They can do DI into POJO Classes.

SAX Parser: Its IOC parser which uses to read your document (xml file) and check whether it is well formed and valid.

BeanFactory Container:-
At the time of loading IOC core container checks document and first time user request its creates the the instance bean declaration only. If user is requesting again then
it will not create instance while it will return which is created first time . So Bean scope is singleton.
If Bean Scope is prototype(Means for each request create one one instance) then it will create instance for each request.

ApplicationContext:-
At the time of loading IOC J2EE container checks document and  its creates the the instance for each bean declaration If  Bean scope is singleton.
If Bean Scope is prototype(Means for each request create one one instance) then at the time of loading it will not create any instance while user will request that time it will create instance for each instance.

So if scope is prototype in that case both BeanFactory and ApplicationContext container behaviour is same.

---------------------------------------
Dependency Injection:
<!-- Restrict to id instead of  using anyone else  alias and name  -->

Spring.xml : till 9 th Lecture:

<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans>
<bean id="t" class="com.SpringDemo.Test"> </bean>
<bean id="triangle" class="com.SpringDemo.Triangle" name="triangle-name">
<!--  <property name="type" value="Equilateral"></property> --> <!-- setter injection -->
<!--  <constructor-arg type="java.lang.String" value="Equilateral" /> --> <!-- constructor injection -->
<!--  <constructor-arg type="int" value='20' />  -->
<!--<constructor-arg index="0" value="Equilateral" />-->
<!--<constructor-arg index="1" value='20' />-->
<property name="pointA" ref="point1">

</property>

<property name="pointB">
   <bean class="com.SpringDemo.Point">                              <!-- Inner Beans defination -->
         <property name="x"  value="-20"></property>
         <property name="y"  value="0"></property>
   </bean>
</property>

<property name="pointC">
   <bean class="com.SpringDemo.Point"> 
         <property name="x"  value="20"></property>
         <property name="y"  value="0"></property>
   </bean>
</property>
</bean>

<bean id="point1" class="com.SpringDemo.Point"> 
<property name="x"  value="0"></property>
<property name="y"  value="0"></property>
</bean>

<alias name="triangle" alias="triangle-alias"/>

</beans>
--------------------------------------------------------------
Autowiring: It helps us to  skip some of the configuration that we have to do.
Exmaple:

package com.SpringDemo;

public class Point {
	private int x;
	private int y;
	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
	public int getY() {
		return y;
	}
	public void setY(int y) {
		this.y = y;
	}
	

}
--------
package com.SpringDemo;

import java.util.List;

public class Triangle {
	
/*	private List<Point> points;
	
	

public List<Point> getPoints() {
		return points;
	}



	public void setPoints(List<Point> points) {
		this.points = points;	
	}
	
		public void draw() {
		
		for(Point point: points)
		{
		System.out.println(" point = (" +point.getX() +"," + point.getY() + ")");

		}
		}
*/


	/*	  private String type;
	  private int height;
	  
	  
	  public int getHeight() {
		return height;
	}

	public String getType()
	  {
		  return type;
	  }
	  public Triangle(String type)  //constructor Injection
	  {
		  this.type=type;
	  }
	  public Triangle(String type,int height)  //constructor Injection
	  {
		  this.type=type;
		  this.height=height;
	  }
	  
	  public Triangle(int height)  //constructor Injection
	  {
		  this.height=height;
	  }
	  public void setType(String type)   //setter Injection
	  {
		  this.type=type;
	  }
	  
	public void draw() {
		System.out.println(getType() + " Triangle has been drawn of height "+ getHeight() );
	}*/
	//Class object Injecting
	private Point pointA;
	private Point pointB;
	private Point pointC;
	
	
	public Point getPointA() {
		return pointA;
	}


	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}


	public Point getPointB() {
		return pointB;
	}


	public void setPointB(Point pointB) {
		this.pointB = pointB;
	}


	public Point getPointC() {
		return pointC;
	}


	public void setPointC(Point pointC) {
		this.pointC = pointC;
	}

	public void draw() {
		
		System.out.println("point A = ("+ getPointA().getX()+" , "+ getPointA().getY()+")");
		System.out.println("point B = ("+ getPointB().getX()+" , "+ getPointB().getY()+")");
		System.out.println("point C = ("+ getPointC().getX()+" , "+ getPointC().getY()+")");
			
		}

}
------------
spring.xml
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans>
<bean id="t" class="com.SpringDemo.Test"> </bean>
<bean id="triangle" class="com.SpringDemo.Triangle" name="triangle-name" autowire="byName">
 <!--   <property name="points">
       <list>             
              <ref bean="point1" />
              <ref bean="point2" />
              <ref bean="point3" />
       </list>
  </property>  -->
</bean>


   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="0"></property>
         <property name="y"  value="0"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                              <!-- Inner Beans defination -->
         <property name="x"  value="-20"></property>
         <property name="y"  value="0"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="20"></property>
         <property name="y"  value="0"></property>
   </bean>


<alias name="triangle" alias="triangle-alias"/>

</beans>
-------------
package com.SpringDemo;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

public class DrawingApp {

	public static void main(String[] args) { 
		//Resource r=new ClassPathResource("resource/spring.xml");
        //BeanFactory factory=new XmlBeanFactory(r);
		ApplicationContext context = new ClassPathXmlApplicationContext("resource/spring.xml");
    	Triangle  triangle =(Triangle)context.getBean("triangle");
		triangle.draw();

	}

}
-----------------------------------------------------------
Collections:

package com.SpringDemo;

public class Person {
	
	private String name;
	private String address;
	private int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	

}
//
package com.SpringDemo;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

public class Customer 
{
	private List<Person> lists;
	private Set<Person> sets;
	private Map<Integer, Object> maps;
	private Properties pros;
	

	
	public Map<Integer, Object> getMaps() {
		return maps;
	}
	public void setMaps(Map<Integer, Object> maps) {
		this.maps = maps;
	}
	public List<Person> getLists() {
		return lists;
	}
	public void setLists(List<Person> lists) {
		this.lists = lists;
	}
	public Set<Person> getSets() {
		return sets;
	}
	public void setSets(Set<Person> sets) {
		this.sets = sets;
	}
	
	
	public Properties getPros() {
		return pros;
	}
	public void setPros(Properties pros) {
		this.pros = pros;
	}
	
	public void showDetails()
	{
		for(Person list: lists)
		{
		System.out.println("List Detail are = (" +list.getName()+"," + list.getAddress() + ","+list.getAge() +")");

		}
		
		for(Person set: sets)
		{
		System.out.println("Set Detail are = (" +set.getName()+"," + set.getAddress() + ","+set.getAge() +")");
		}
		
		for(Map.Entry<Integer, Object> entry : maps.entrySet()) {
		      System.out.println("Key : " + entry.getKey() + " value : " + entry.getValue());
		    }
		
	}
	
}
//
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	

   <beans>
	<bean id="CustomerBean" class="com.SpringDemo.Customer">

		<!-- java.util.List -->
		<property name="lists">
			<list>
				
				<!--    <ref bean="PersonBean" /> --> 
				<bean class="com.SpringDemo.Person">
					<property name="name" value="Albel List" />
					<property name="address" value="BTM layout" />
					<property name="age" value="30" />
				</bean>
			</list>
		</property>

		<!-- java.util.Set -->
		<property name="sets">
			<set>

			<!-- 	<ref bean="PersonBean" />   -->
				<bean class="com.SpringDemo.Person">
					<property name="name" value="Murari Set" />
					<property name="address" value="kadiyahat" />
					<property name="age" value="31" />
				</bean>
			</set>
		</property>

		<!-- java.util.Map -->
		<property name="maps">
			<map>
			    <entry key="1" value="Albel" /> 
				<entry key="2" value="Murari" />
				<entry key="3" value="Nishat" />
					
			</map>
		</property>

		<!-- java.util.Properties -->
		<property name="pros">
			<props>
				<prop key="admin">admin@nospam.com</prop>
				<prop key="support">support@nospam.com</prop>
			</props>
		</property>

	</bean>

	<bean id="PersonBean" class="com.SpringDemo.Person">
		<property name="name" value="Unknown" />
		<property name="address" value="Bangalore" />
		<property name="age" value="33" />
	</bean>

</beans>
//
package com.SpringDemo;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
    	//Resource r=new ClassPathResource("resource/spring.xml");
        //BeanFactory factory=new XmlBeanFactory(r);
    	//Test  t =(Test)factory.getBean("t");
    	ApplicationContext context = new ClassPathXmlApplicationContext("resource/SpringBeans.xml");
    	Customer  cust =(Customer)context.getBean("CustomerBean");
    	cust.showDetails();
    	//System.out.println(cust.getMaps().toString());
    	
    	
    }
}
---------------------------------
Beans  Scope:
package com.SpringDemo;

public class Point {
	private int x;
	private int y;
	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
	public int getY() {
		return y;
	}
	public void setY(int y) {
		this.y = y;
	}
	
	//
	package com.SpringDemo;

import java.util.List;

public class Triangle {
	
	private Point pointA;
	private Point pointB;
	private Point pointC;
	
	
	public Point getPointA() {
		return pointA;
	}


	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}


	public Point getPointB() {
		return pointB;
	}


	public void setPointB(Point pointB) {
		this.pointB = pointB;
	}


	public Point getPointC() {
		return pointC;
	}


	public void setPointC(Point pointC) {
		this.pointC = pointC;
	}

	public void draw() {
		
		System.out.println("point A = ("+ getPointA().getX()+" , "+ getPointA().getY()+")");
		System.out.println("point B = ("+ getPointB().getX()+" , "+ getPointB().getY()+")");
		System.out.println("point C = ("+ getPointC().getX()+" , "+ getPointC().getY()+")");
			
		}

}


}
//
spring.xml

<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans>
<bean id="t" class="com.SpringDemo.Test"> </bean>
<bean id="triangle" class="com.SpringDemo.Triangle" name="triangle-name" autowire="byName" scope="prototype"> <!--scope="singleton" -->

</bean>


   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="0"></property>
         <property name="y"  value="0"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                             
         <property name="x"  value="-20"></property>
         <property name="y"  value="0"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="20"></property>
         <property name="y"  value="0"></property>
   </bean>


<alias name="triangle" alias="triangle-alias"/>

</beans>

//
package com.SpringDemo;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

public class DrawingApp {

	public static void main(String[] args) { 
		//Resource r=new ClassPathResource("resource/spring.xml");
        //BeanFactory factory=new XmlBeanFactory(r);
		ApplicationContext context = new ClassPathXmlApplicationContext("resource/spring.xml"); //Itializing application context or start container.
    	Triangle  triangle =(Triangle)context.getBean("triangle");
		triangle.draw();

	}

}
---------------------------
Using ApplicationContextAware and BeanNameAware:

Aware Interface:
Both BeanNameAware and BeanFactoryAware belong to the org.springframework.beans.factory.Aware root marker interface. This uses setter injection to get an object during the application context startup.

The Aware interface is a mix of callback, listener, and observer design patterns. It indicates that the bean is eligible to be notified by the Spring container through the callback methods.

1.BeanNameAware:
BeanNameAware makes the object aware of the bean name defined in the container
BeanNameAware can be used to set bean name. The class has to implement interface BeanNameAware and override its method setBeanName(String beanName). When the bean is loaded by spring container, the bean name is set to this method.

2.BeanFactoryAware:
BeanFactoryAware is used to inject the BeanFactory object. This way we get access to the BeanFactory which created the object.
public class MyBeanFactory implements BeanFactoryAware {
 
    private BeanFactory beanFactory;
 
    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
    }
 
    public void getMyBeanName() {
        MyBeanName myBeanName = beanFactory.getBean(MyBeanName.class);
        System.out.println(beanFactory.isSingleton("myCustomBeanName"));
    }
}

Example:
We are using above same spring.xml and Point class.

Triangle class
package com.SpringDemo;

import java.util.List;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;

public class Triangle implements ApplicationContextAware , BeanNameAware
{
	

	private Point pointA;
	private Point pointB;
	private Point pointC;
	private ApplicationContext context=null;
	private BeanNameAware bn=null;
	
	
	public Point getPointA() {
		return pointA;
	}


	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}


	public Point getPointB() {
		return pointB;
	}


	public void setPointB(Point pointB) {
		this.pointB = pointB;
	}


	public Point getPointC() {
		return pointC;
	}


	public void setPointC(Point pointC) {
		this.pointC = pointC;
	}

	public void draw() {
		
		System.out.println("point A = ("+ getPointA().getX()+" , "+ getPointA().getY()+")");
		System.out.println("point B = ("+ getPointB().getX()+" , "+ getPointB().getY()+")");
		System.out.println("point C = ("+ getPointC().getX()+" , "+ getPointC().getY()+")");
		
			
		}


	public void setApplicationContext(ApplicationContext context) throws BeansException {
		this.context=context;
		
	}

	public void setBeanName(String BeanName) {
		System.out.println("Bean Name is  = "+ BeanName);

	}
	


}
-----------------
package com.SpringDemo;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

public class DrawingApp {
	
/*	@Bean(name = "myCustomBeanName")
    public static Triangle getMyBeanName() 
	{
        return new Triangle();
    }*/

	public static void main(String[] args) { 
		//Resource r=new ClassPathResource("resource/spring.xml");
        //BeanFactory factory=new XmlBeanFactory(r);
		
		ApplicationContext context = new ClassPathXmlApplicationContext("resource/spring.xml"); //Itializing application context or start container.
    	Triangle  triangle =(Triangle)context.getBean("triangle");
		triangle.draw();
        
	}

}
------------------------------------------------------------------------------------------------------------
Bean Defination Inheritance:
If the bean having common property in that case just inheritance the bean and use their property.


point and DrawingApp class is same ablve one

package com.SpringDemo;

import java.util.List;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;

public class Triangle
{
	

	private Point pointA;
	private Point pointB;
	private Point pointC;

	
	public Point getPointA() {
		return pointA;
	}


	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}


	public Point getPointB() {
		return pointB;
	}


	public void setPointB(Point pointB) {
		this.pointB = pointB;
	}


	public Point getPointC() {
		return pointC;
	}


	public void setPointC(Point pointC) {
		this.pointC = pointC;
	}

	public void draw() {
		
		System.out.println("point A = ("+ getPointA().getX()+" , "+ getPointA().getY()+")");
		System.out.println("point B = ("+ getPointB().getX()+" , "+ getPointB().getY()+")");
		System.out.println("point C = ("+ getPointC().getX()+" , "+ getPointC().getY()+")");
			
		}

}
//
Spring.xml
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans>

<bean id="parenttriangle" class="com.SpringDemo.Triangle" >
       <property name="pointA"  ref="pointA" /> 
       
</bean>

<bean id="triangle" class="com.SpringDemo.Triangle" parent="parenttriangle">
      
       <property name="pointB"  ref="pointB" />
       <property name="pointC"  ref="pointC" />
</bean>


   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="0"></property>
         <property name="y"  value="0"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                              <!-- Inner Beans defination -->
         <property name="x"  value="-20"></property>
         <property name="y"  value="0"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="20"></property>
         <property name="y"  value="0"></property>
   </bean>


<alias name="triangle" alias="triangle-alias"/>

</beans>
//

//
--------------------------------
Using list:
point and DrawingApp class is same ablve one
package com.SpringDemo;

import java.util.List;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;

public class Triangle
{
	

	private List<Point> points;
/*	private Point pointB;
	private Point pointC;*/

	public List<Point> getPoints() {
		return points;
	}

	public void setPoints(List<Point> points) {
		this.points = points;
	}
	
	public void draw() {
		
		for(Point point: points)
		{
		System.out.println(" point = (" +point.getX() +"," + point.getY() + ")");

		}
		}
}
//

<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans>

<bean id="parenttriangle" class="com.SpringDemo.Triangle" >
       <property name="points">
       <list>
       <ref bean ="pointA"/>  
       </list>  
       </property> 
       
</bean>

<bean id="triangle" class="com.SpringDemo.Triangle" parent="parenttriangle">
    <property name="points">
       <list merge="true">
       <ref bean ="pointB"/>  
       <ref bean ="pointC"/> 
       </list>  
       </property>
</bean>


   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="0"></property>
         <property name="y"  value="0"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                              <!-- Inner Beans defination -->
         <property name="x"  value="-20"></property>
         <property name="y"  value="0"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="20"></property>
         <property name="y"  value="0"></property>
   </bean>


<alias name="triangle" alias="triangle-alias"/>

</beans>
------------------------------------------------------------------------------------
LifeCycle Callback:- 

IniitializingBean interface - tells us my beans needs to know when it is initialized

Example:
Point class is same.

package com.SpringDemo;

import java.util.List;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;

public class Triangle implements InitializingBean,DisposableBean
{

	private Point pointA;
	private Point pointB;
	private Point pointC;
	
	public Point getPointA() {
		return pointA;
	}


	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}


	public Point getPointB() {
		return pointB;
	}


	public void setPointB(Point pointB) {
		this.pointB = pointB;
	}


	public Point getPointC() {
		return pointC;
	}


	public void setPointC(Point pointC) {
		this.pointC = pointC;
	}

	public void draw() {
		
		System.out.println("point A = ("+ getPointA().getX()+" , "+ getPointA().getY()+")");
		System.out.println("point B = ("+ getPointB().getX()+" , "+ getPointB().getY()+")");
		System.out.println("point C = ("+ getPointC().getX()+" , "+ getPointC().getY()+")");
			
		}

//This method gets call when Bean has finished initialization
	public void afterPropertiesSet() throws Exception {
		// TODO Auto-generated method stub
		System.out.println("InitializingBean init method called for Triangle!!");
	}

// This method gets call before destroy the bean
	public void destroy() throws Exception {
		// TODO Auto-generated method stub
		System.out.println("DisposableBean destroy method called for Triangle!!");
	} 
	

}
//
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans>


<bean id="triangle" class="com.SpringDemo.Triangle">
    <property name="pointA" ref="pointA"/>
    <property name="pointB" ref="pointB"/>
    <property name="pointC" ref="pointC"/>
       
</bean>


   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="0"></property>
         <property name="y"  value="0"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                              <!-- Inner Beans defination -->
         <property name="x"  value="-20"></property>
         <property name="y"  value="0"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="20"></property>
         <property name="y"  value="0"></property>
   </bean>


<alias name="triangle" alias="triangle-alias"/>

</beans>
//
package com.SpringDemo;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

public class DrawingApp {


	public static void main(String[] args) { 
		//Resource r=new ClassPathResource("resource/spring.xml");
        //BeanFactory factory=new XmlBeanFactory(r);
		//this is the adding for git version changes
		
		AbstractApplicationContext context = new ClassPathXmlApplicationContext("resource/spring.xml"); //Itializing application context or start container.
		context.registerShutdownHook();
		Triangle  triangle =(Triangle)context.getBean("triangle");
		triangle.draw();
		System.out.println("output = "+context.getBeanDefinitionCount());
		
        
	}

}
//
Disadvantage:
in this approache we are implements two spring interface so we are binding our bean to spring itself.

Point class is same.

package com.SpringDemo;

import java.util.List;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;

public class Triangle implements InitializingBean,DisposableBean
{

	private Point pointA;
	private Point pointB;
	private Point pointC;
	
	public Point getPointA() {
		return pointA;
	}


	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}


	public Point getPointB() {
		return pointB;
	}


	public void setPointB(Point pointB) {
		this.pointB = pointB;
	}


	public Point getPointC() {
		return pointC;
	}


	public void setPointC(Point pointC) {
		this.pointC = pointC;
	}

	public void draw() {
		
		System.out.println("point A = ("+ getPointA().getX()+" , "+ getPointA().getY()+")");
		System.out.println("point B = ("+ getPointB().getX()+" , "+ getPointB().getY()+")");
		System.out.println("point C = ("+ getPointC().getX()+" , "+ getPointC().getY()+")");
			
		}

//This method gets call when Bean has finished initialization
	public void afterPropertiesSet() throws Exception {
		// TODO Auto-generated method stub
		System.out.println("InitializingBean init method called for Triangle!!");
	}

// This method gets call before destroy the bean
	public void destroy() throws Exception {
		// TODO Auto-generated method stub
		System.out.println("DisposableBean destroy method called for Triangle!!");
	} 
	
	 public void  myInit() {
		 System.out.println("My myInit method called for Triangle!!"); 
	 }
     public void cleanUp(){
	   System.out.println("My Cleanup method called for Triangle!!");
    }
}
//
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans default-init-method="myInit" default-destroy-method="cleanUp">

<bean id="triangle" class="com.SpringDemo.Triangle" >
    <property name="pointA" ref="pointA"/>
    <property name="pointB" ref="pointB"/>
    <property name="pointC" ref="pointC"/>
       
</bean>


   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="0"></property>
         <property name="y"  value="0"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                              <!-- Inner Beans defination -->
         <property name="x"  value="-20"></property>
         <property name="y"  value="0"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="20"></property>
         <property name="y"  value="0"></property>
   </bean>


<alias name="triangle" alias="triangle-alias"/>

</beans>
//
package com.SpringDemo;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

public class DrawingApp {


	public static void main(String[] args) { 
		//Resource r=new ClassPathResource("resource/spring.xml");
        //BeanFactory factory=new XmlBeanFactory(r);
		//this is the adding for git version changes
		
		AbstractApplicationContext context = new ClassPathXmlApplicationContext("resource/spring.xml"); //Itializing application context or start container.
		context.registerShutdownHook();
		Triangle  triangle =(Triangle)context.getBean("triangle");
		triangle.draw();
		System.out.println("output = "+context.getBeanDefinitionCount());
		
        
	}

}
Note: In above example we are using both way to initialization and clean up activity by choice you can implement anyone way.
---------------------------------------------------------------------------------------
BeanPostProcessor:
BeanPostProcessor interface consists of exactly two callback methods i.e. postProcessBeforeInitialization() and postProcessAfterInitialization().

For each bean instance that is created by the container, the post-processor gets a callback from the container both time – before container initialization methods are called as well as after any bean initialization callbacks.

A bean post-processor typically checks for callback interfaces or may wrap a bean with a proxy. Some Spring AOP infrastructure classes (e.g. AbstractAdvisingBeanPostProcessor) are implemented as bean post-processors in order to provide proxy-wrapping logic.

Example:

*Point Class is same.
package com.SpringDemo;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class DisplayNameBeanPostProcessor implements BeanPostProcessor{

	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException 
    {
        System.out.println("Called postProcessBeforeInitialization() for :" + beanName);
        return bean;
    }
     
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException 
    {
        System.out.println("Called postProcessAfterInitialization() for :" + beanName);
        return bean;
    }
	
}
//
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans >

<bean id="triangle" class="com.SpringDemo.Triangle" >
    <property name="pointA" ref="pointA"/>
    <property name="pointB" ref="pointB"/>
    <property name="pointC" ref="pointC"/>
       
</bean>


   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="0"></property>
         <property name="y"  value="0"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                              <!-- Inner Beans defination -->
         <property name="x"  value="-20"></property>
         <property name="y"  value="0"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="20"></property>
         <property name="y"  value="0"></property>
   </bean>

<bean id="customBeanPostProcessor"
               class="com.SpringDemo.DisplayNameBeanPostProcessor" />

</beans>
//
package com.SpringDemo;

import java.util.List;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;

public class Triangle
{

	private Point pointA;
	private Point pointB;
	private Point pointC;
	
	public Point getPointA() {
		return pointA;
	}


	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}


	public Point getPointB() {
		return pointB;
	}


	public void setPointB(Point pointB) {
		this.pointB = pointB;
	}


	public Point getPointC() {
		return pointC;
	}


	public void setPointC(Point pointC) {
		this.pointC = pointC;
	}

	public void draw() {
		
		System.out.println("point A = ("+ getPointA().getX()+" , "+ getPointA().getY()+")");
		System.out.println("point B = ("+ getPointB().getX()+" , "+ getPointB().getY()+")");
		System.out.println("point C = ("+ getPointC().getX()+" , "+ getPointC().getY()+")");
			
		}


}
//
package com.SpringDemo;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

public class DrawingApp {


	public static void main(String[] args) { 
		//Resource r=new ClassPathResource("resource/spring.xml");
        //BeanFactory factory=new XmlBeanFactory(r);
		//this is the adding for git version changes
		
		AbstractApplicationContext context = new ClassPathXmlApplicationContext("resource/spring.xml"); //Itializing application context or start container.
		//context.registerShutdownHook();
		Triangle  triangle =(Triangle)context.getBean("triangle");
		triangle.draw();
		System.out.println("output = "+context.getBeanDefinitionCount());
		
        
	}

}
//
------------------------------------
BeanFactoryPostProcessor:
BeanFactoryPostProcessor works on the bean definitions or configuration meta data of the bean before beans are actually created. Spring provides multiple BeanFactoryPostProcessor beans, so it invoked to resolve run time dependencies such reading value from external property files. In Spring application, BeanFactoryPostProcessor can modify the definition of any bean.


Example:
Triangle,Point and DrawingApp are same previous one.

<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans >

<bean id="triangle" class="com.SpringDemo.Triangle" >
    <property name="pointA" ref="pointA"/>
    <property name="pointB" ref="pointB"/>
    <property name="pointC" ref="pointC"/>
       
</bean>


   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="0"></property>
         <property name="y"  value="0"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                              <!-- Inner Beans defination -->
         <property name="x"  value="-20"></property>
         <property name="y"  value="0"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="20"></property>
         <property name="y"  value="0"></property>
   </bean>

<bean class="com.SpringDemo.MyBeanFactoryPP" />

</beans>
//
package com.SpringDemo;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;

public class MyBeanFactoryPP implements BeanFactoryPostProcessor{

	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		 System.out.println("Called BeanFactoryPostProcessor " );
		
	}

}

BeanFactoryPostProcessor with properties file:
DrawingApp ,point and Triangle class are same.

<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans >

<bean id="triangle" class="com.SpringDemo.Triangle" >
    <property name="pointA" ref="pointA"/>
    <property name="pointB" ref="pointB"/>
    <property name="pointC" ref="pointC"/>
       
</bean>


   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="${pointA.pointX}"></property>
         <property name="y"  value="${pointA.pointY}"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                              <!-- Inner Beans defination -->
         <property name="x"  value="${pointB.pointX}"></property>
         <property name="y"  value="${pointB.pointY}"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="${pointC.pointX}"></property>
         <property name="y"  value="${pointC.pointY}"></property>
   </bean>

<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" >
<property name="locations" value="resource/pointsconfig.properties"/>
</bean>

</beans>
//
pointsconfig.properties :-

pointA.pointX=0
pointA.pointY=0
pointB.pointX=-20
pointB.pointY=0
pointC.pointX=0
pointC.pointY=20
-----------
The differences about BeanFactoryPostProcessor and BeanPostProcessor:

1. A bean implementing BeanFactoryPostProcessor is called when all bean definitions will have been loaded, but no beans will have been instantiated yet. This allows for overriding or adding properties even to eager-initializing beans. This will let you have access to all the beans that you have defined in XML or that are annotated (scanned via component-scan).

2. A bean implementing BeanPostProcessor operate on bean (or object) instances which means that when the Spring IoC container instantiates a bean instance then BeanPostProcessor interfaces do their work.

3. BeanFactoryPostProcessor implementations are "called" during startup of the Spring context after all bean definitions will have been loaded while BeanPostProcessor are "called" when the Spring IoC container instantiates a bean (i.e. during the startup for all the singleton and on demand for the proptotypes one)
--------------------------------------------------------------------------------------------------------------
Coding to Interface in DI:

Point and Properties are same.
Example:
package com.SpringDemo;

public interface Shape {
	public void draw();

}
//

package com.SpringDemo;

import java.util.List;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;

public class Triangle implements Shape
{

	private Point pointA;
	private Point pointB;
	private Point pointC;
	
	public Point getPointA() {
		return pointA;
	}


	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}


	public Point getPointB() {
		return pointB;
	}


	public void setPointB(Point pointB) {
		this.pointB = pointB;
	}


	public Point getPointC() {
		return pointC;
	}


	public void setPointC(Point pointC) {
		this.pointC = pointC;
	}

	public void draw() {
		System.out.println("Drawing Triangle ");
		System.out.println("point A = ("+ getPointA().getX()+" , "+ getPointA().getY()+")");
		System.out.println("point B = ("+ getPointB().getX()+" , "+ getPointB().getY()+")");
		System.out.println("point C = ("+ getPointC().getX()+" , "+ getPointC().getY()+")");
			
		}


}
//

package com.SpringDemo;

public class Circle implements Shape{
     
	private Point center;
	
	public void draw() {
		System.out.println("Drawing Circle ");
		System.out.println("Point are = "+center.getX()+","+center.getY());
		
	}

	public Point getCenter() {
		return center;
	}

	public void setCenter(Point center) {
		this.center = center;
	}
	

}
//

<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans >

<bean id="triangle" class="com.SpringDemo.Triangle" >
    <property name="pointA" ref="pointA"/>
    <property name="pointB" ref="pointB"/>
    <property name="pointC" ref="pointC"/>
       
</bean>
<bean id="circle" class="com.SpringDemo.Circle" >
    <property name="center" ref="pointA"/>
   
</bean>

   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="${pointA.pointX}"></property>
         <property name="y"  value="${pointA.pointY}"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                              <!-- Inner Beans defination -->
         <property name="x"  value="${pointB.pointX}"></property>
         <property name="y"  value="${pointB.pointY}"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="${pointC.pointX}"></property>
         <property name="y"  value="${pointC.pointY}"></property>
   </bean>

<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" >
<property name="locations" value="resource/pointsconfig.properties"/>
</bean>

</beans>
//
package com.SpringDemo;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

public class DrawingApp {


	public static void main(String[] args) { 
		
		AbstractApplicationContext context = new ClassPathXmlApplicationContext("resource/spring.xml"); //Itializing application context or start container.
		Shape  shape =(Shape)context.getBean("triangle");
		shape.draw();    
	}

}
------------------------------------------------------------------------------------------------
@Required Annotation:-

Example:
Except below two class everything is same as above.
package com.SpringDemo;

import org.springframework.beans.factory.annotation.Required;

public class Circle implements Shape{
     
	private Point center;
	
	public void draw() {
		System.out.println("Drawing Circle ");
		System.out.println("Point are = "+center.getX()+","+center.getY());
		
	}

	public Point getCenter() {
		return center;
	}
    @Required
	public void setCenter(Point center) {
		this.center = center;
	}
	

}
//
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans >

<bean id="triangle" class="com.SpringDemo.Triangle" >
    <property name="pointA" ref="pointA"/>
    <property name="pointB" ref="pointB"/>
    <property name="pointC" ref="pointC"/>
       
</bean>
<bean id="circle" class="com.SpringDemo.Circle" >
  <!--  <property name="center" ref="pointA"/> -->
   
</bean>

   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="${pointA.pointX}"></property>
         <property name="y"  value="${pointA.pointY}"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                              <!-- Inner Beans defination -->
         <property name="x"  value="${pointB.pointX}"></property>
         <property name="y"  value="${pointB.pointY}"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="${pointC.pointX}"></property>
         <property name="y"  value="${pointC.pointY}"></property>
   </bean>

<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" >
<property name="locations" value="resource/pointsconfig.properties"/>
</bean>

<bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" /> <!-- This method checks for all required annotation if it is not there then Spring through error -->

</beans>
-------------------------------------------------------------------
@Autowired :

It checks for type in xml file if there is only one bean of the same type then it autowired without any problem.
If there are many beans of the same type in the xml file then it looks for name if any matches it autowire that bean.
If name doesn't matches then it looks for qualifier in the bean which you have defined in the class.

Example:
Othser class same as above.
(1)
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans >

<!-- <bean id="triangle" class="com.SpringDemo.Triangle" >
    <property name="pointA" ref="pointA"/>
    <property name="pointB" ref="pointB"/>
    <property name="pointC" ref="pointC"/>
       
</bean>
 -->

   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="${pointA.pointX}"></property>
         <property name="y"  value="${pointA.pointY}"></property>
   </bean>

<!--    <bean id="pointB" class="com.SpringDemo.Point">                            
         <property name="x"  value="${pointB.pointX}"></property>
         <property name="y"  value="${pointB.pointY}"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="${pointC.pointX}"></property>
         <property name="y"  value="${pointC.pointY}"></property>
   </bean>
 -->
<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" >
<property name="locations" value="resource/pointsconfig.properties"/>
</bean>
<bean id="circle" class="com.SpringDemo.Circle" >
  <!--  <property name="center" ref="pointA"/> -->
</bean>
<!-- <bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" /> -->
<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>
</beans>
//
package com.SpringDemo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Required;

public class Circle implements Shape{
     
	private Point center;
	
	public void draw() {
		System.out.println("Drawing Circle ");
		System.out.println("Point are = "+center.getX()+","+center.getY());
		
	}

	public Point getCenter() {
		return center;
	}
    @Autowired
	public void setCenter(Point center) {
		this.center = center;
	}
	

}

Case (2) Multiple Type:
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd">	
<beans >

<!-- <bean id="triangle" class="com.SpringDemo.Triangle" >
    <property name="pointA" ref="pointA"/>
    <property name="pointB" ref="pointB"/>
    <property name="pointC" ref="pointC"/>
       
</bean>
 -->

   <bean id="pointA" class="com.SpringDemo.Point"> 
         <property name="x"  value="${pointA.pointX}"></property>
         <property name="y"  value="${pointA.pointY}"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                            
         <property name="x"  value="${pointB.pointX}"></property>
         <property name="y"  value="${pointB.pointY}"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="${pointC.pointX}"></property>
         <property name="y"  value="${pointC.pointY}"></property>
   </bean>

<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" >
<property name="locations" value="resource/pointsconfig.properties"/>
</bean>
<bean id="circle" class="com.SpringDemo.Circle" >
  <!--  <property name="center" ref="pointA"/> -->
</bean>
<!-- <bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" /> -->
<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>
</beans>

Case (3)  Using Qualifier:

XML:

<?xml version = "1.0" encoding = "UTF-8"?>
<!-- <!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
<beans> -->
<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                         http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"
   xmlns:context = "http://www.springframework.org/schema/context">
  

<!-- <bean id="triangle" class="com.SpringDemo.Triangle" >
    <property name="pointA" ref="pointA"/>
    <property name="pointB" ref="pointB"/>
    <property name="pointC" ref="pointC"/>
       
</bean>
 -->

   <bean id="pointA" class="com.SpringDemo.Point"> 
         <qualifier value="circleRelated" />
         <property name="x"  value="${pointA.pointX}"></property>
         <property name="y"  value="${pointA.pointY}"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                            
         <property name="x"  value="${pointB.pointX}"></property>
         <property name="y"  value="${pointB.pointY}"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="${pointC.pointX}"></property>
         <property name="y"  value="${pointC.pointY}"></property>
   </bean>

<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" >
<property name="locations" value="resource/pointsconfig.properties"/>
</bean>
<bean id="circle" class="com.SpringDemo.Circle" >
  <!--  <property name="center" ref="pointA"/> -->
</bean>
<!-- <bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" /> -->
<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>
</beans>
//
package com.SpringDemo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Required;

public class Circle implements Shape{
     
	private Point center;
	
	public void draw() {
		System.out.println("Drawing Circle ");
		System.out.println("Point are = "+center.getX()+","+center.getY());
		
	}

	public Point getCenter() {
		return center;
	}
    @Autowired
    @Qualifier("circleRelated")
	public void setCenter(Point center) {
		this.center = center;
	}
	

}
Everything are same as previous.
-----------------------------------------------------------------------
20-practical is pending
@Resource Annotation: 
Its going to inject bean by name. 
Example: @Resource(name="pointC")

@PostConstruct : it runs after bean has initialized. like - call before initialization method.
@PreDestroy : It runs before bean being destroy. like - call before destroy method.

----------------------
21-practical is pending
@Component : - By using this bean no need to create bean in xml for java class just write this annotation before java class it gonna register java class as bean with container and we use to scan this annotation 

<context:component-scan base-package="com.SpringDemo" />

@Service: 

Spring @Service annotation is a specialization of @Component annotation. Spring Service annotation can be applied only to classes. It is used to mark the class as a service provider.

Spring @Service annotation is used with classes that provide some business functionalities. Spring context will autodetect these classes when annotation-based configuration and classpath scanning is used.

@Repository :
Spring @Repository annotation is used to indicate that the class provides the mechanism for storage, retrieval, search, update and delete operation on objects.

Spring @Repository Annotation
Spring Repository annotation is a specialization of @Component annotation, so Spring Repository classes are autodetected by spring framework through classpath scanning.

Spring Repository is very close to DAO pattern where DAO classes are responsible for providing CRUD operations on database tables. However, if you are using Spring Data for managing database operations, then you should use Spring Data Repository interface.

@Controller: The @Controller annotation is used to mark any java class as a controller class.
-------------------------------------------------
MessageSource: reading text from properties file.

<!-- <?xml version = "1.0" encoding = "UTF-8"?> -->
<!-- <!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
<beans> -->
<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
                         http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"
   xmlns:context = "http://www.springframework.org/schema/context">

<context:annotation-config/>

<context:component-scan base-package="com.SpringDemo" />

<!-- <bean id="triangle" class="com.SpringDemo.Triangle" >
    <property name="pointA" ref="pointA"/>
    <property name="pointB" ref="pointB"/>
    <property name="pointC" ref="pointC"/>
       
</bean>
 -->
<bean id="circle" class="com.SpringDemo.Circle" > </bean>

   <bean id="pointA" class="com.SpringDemo.Point">  
         <qualifier value="circleRelated" />    
         <property name="x"  value="${pointA.pointX}"></property>
         <property name="y"  value="${pointA.pointY}"></property>
   </bean>

   <bean id="pointB" class="com.SpringDemo.Point">                            
         <property name="x"  value="${pointB.pointX}"></property>
         <property name="y"  value="${pointB.pointY}"></property>
   </bean>
   
   <bean id="pointC" class="com.SpringDemo.Point"> 
         <property name="x"  value="${pointC.pointX}"></property>
         <property name="y"  value="${pointC.pointY}"></property>
   </bean>

<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" >
<property name="locations" value="resource/pointsconfig.properties"/>
</bean>
    <bean id="messageSorce" class="org.springframework.context.support.ResourceBundleMessageSource">
   
     <property name="basenames">
     <list>
     <value>mymessage</value>
     </list>
     </property>
    </bean>

<!-- <bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/> -->
</beans>
//
package com.SpringDemo;

import javax.annotation.Resource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Required;
import org.springframework.context.MessageSource;
import org.springframework.stereotype.Service;


public class Circle implements Shape{
     
	private Point center;
	@Autowired
	private MessageSource messageSource;
	
	public MessageSource getMessageSource() {
		return messageSource;
	}

	public void setMessageSource(MessageSource messageSource) {
		this.messageSource = messageSource;
	}

	public void draw() {
		System.out.println("Drawing Circle ");
		System.out.println("Point are = "+center.getX()+","+center.getY());
		/*System.out.println(this.messageSource.getMessage("drawing.point", new Object[] {center.getX(), center.getY()} , "Default Point ", null));
		System.out.println(this.messageSource.getMessage("greeting", null, "Default Hello Albel", null));
		*/
	}

	public Point getCenter() {
		return center;
	}
	@Autowired
	@Qualifier("circleRelated")
	/*@Resource(name="pointC")*/
	public void setCenter(Point center) {
		this.center = center;
	}
	
	

}
//
package com.SpringDemo;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.FileSystemResource;


public class DrawingApp {

	public static void main(String[] args) { 
		
		ApplicationContext context = new ClassPathXmlApplicationContext("resource/spring.xml"); //Itializing application context or start container.
		Shape  shape =(Shape)context.getBean("circle");
        shape.draw(); 
        System.out.println(context.getMessage("greeting", null, "greeting not found", null));
       
	}

}
//
greeting=HelloAlbel
drawing.circle=Drawing Circle!
drawing.point=Circle point is: [{0}, {1}]
-------------------------------------------------------------------
